[{"title":"随记","url":"/2025/08/27/essay/","content":"\n  \n    一个人如果爱你 无论怎么样他都会来找你的不管误会再深 说话再难删除多少次吵架再狠 他都不会放手 所以你还不明白吗？ \n——电影《聊斋：兰若寺》 \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;每个人一辈子都有许多不顺心的事，一件完了一件又来。所以丁香结年年都有。结，是解不完的；人生中的问题也是解不完的，不然，岂不太平淡无味了吗？\n——宗璞\n    \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;天涯各色，人各有志。\n\n    \n  \n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;诗云：“行百里者半于九十。”此言末路之难也。\n\n    \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;如果你把每一天都当做生命的最后一天，你会做些什么？\n\n    \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;且视他人之疑目如盏盏鬼火，大胆地去走你的夜路。\n——史铁生\n    \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;知我者，谓我心忧；不知我者，谓我何求。\n——《黍离》\n\n\n  \n    释意：能够理解我的人，说我是心中忧愁。不能理解我的人，问我在追寻什么。 \n\n  \n\n    \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;天不生无用之人，地不长无名之草。\n\n    \n  \n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;无人扶我青云志，我自踏雪至山巅。&emsp;&emsp;若是命中无此运，孤身亦可登昆仑。&emsp;&emsp;红尘赠我三尺剑，酒看瘦马一世街。  \n\n    \n  \n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;若你不怕失去，就不会被控制，反而能更轻松的驾驭，不要害怕失去，你所能失去的也许本就不属于你，见过花开就好，又何必在乎花属于谁呢，快乐的人专注于所拥有的，不快乐的人专注于所失去的。\n\n    \n  \n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;我来到这个世界，不是为了繁衍后代，而是来看花怎么开，水怎么流，太阳怎么升起，夕阳何时落下，我活在世上，无非是想要明白一些道理，遇见些有趣的事，生命是一场偶然，我在其中寻找因果。\n——王小波\n    \n  \n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;尽人事知天命，得之我幸，失之我命！\n\n    \n  \n\n\n  \n    \n      Note\n\n    \n    \n      猫  \n&emsp;&emsp;从前，我养了一只猫，我有十块钱，会用八块钱给它买吃的，经常给它洗澡，它也很粘我。  \n&emsp;&emsp;后来，我带它出去玩，路人觉得它很可爱，他们给他喂猫粮，火腿肠，我很不开心，因为它是我的。我想把它抱回家，可是它挣脱了我，冲着给它好吃的人喵喵，我抱了几次它都不跟我走还挠伤了我，于是我就转身走了...  \n&emsp;&emsp;再后来，偶然在路上遇到了它，它身上脏兮兮的。路人们只会给它好吃的，陪它玩一玩，却不会带它回家，给它洗澡。它看见我就跟着我回家，我把它关在了门外，它在门外喵喵地叫着，叫的我很难受，可是我不会在要它了。\n    \n  \n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;不管你有多么喜欢一个人，都不要纠结他能陪你多久，或者能不能走到最后。因为我们来这个世界上，朋友也好，爱人也罢，都是上天赐给我们最好的礼物，拥有过就好。&emsp;&emsp;其实有些人的出现，真的只是为了陪你走过一段短暂又美好的时光，即使哪一天形同陌路，你也要知道，有些散场，真的不必说再见，尽力爱过就好。遇见是因为有些债要还，离开时因为还清了，前世不欠今生不见，我大大方方为自己的心动买单，我就要我的人生热烈真诚且坦荡。那些发生过的美好的故事，那么辉煌，那么耀眼。即使最后故事没有后续，也不要觉得遗憾。因为曾经遇到过的刻骨铭心的人，发生过的熠熠生辉的事，终会在你觉得难熬的时候，兀自闪耀，照亮你前行的路。不是每个问题都有答案，不是每件事都能如愿。所以没关系，只是不顺路了而已，以后我们都会光芒万丈。如果注定要分别，那相遇的意义是什么？相遇的意义是，被你改变的那部分的我，代替你永远陪在我身边。 &emsp;&emsp;总有一场相遇，是相互欣赏，共同成长，是隔着茫茫人海，带着温暖奔赴而来，相遇不一定有结局，但一定有意义。 很喜欢的一段话：山鸟与鱼不同路，不用去纠结别人喜不喜欢你，或者为什么他的最好的朋友不是你，因为在冥冥之中是注定的，上天会为你安排合适的人在你身边。别为了不属于你的人而纠结，永远不要忘记用真心换真心，永远做一个真诚的人，即使被辜负也没有关系，这只能证明那个人不够好，配不上你的真诚，时间会筛选你身边的人，值得的人自然值得。风吹哪页读哪页，哪页难懂哪页，你不必非得让那些不喜欢你的人都喜欢你，而是要让那些喜欢你的人，觉得自己真有眼光。\n——《人民日报》\n    \n  \n\n\n\n  \n    \n      Note\n\n    \n    \n      &emsp;&emsp;第1杯，敬我没名没分的陪着妳的日子&emsp;&emsp;第2杯，敬我为了妳毫无底线&emsp;&emsp;第3杯，敬我深夜的眼泪&emsp;&emsp;第4杯，敬我什么也不图和妳一起的真心&emsp;&emsp;第5杯，敬我明知不可为而为之的勇气&emsp;&emsp;第6杯，敬我一直以来的心酸&emsp;&emsp;第7杯，敬我连简单的陪伴都是种奢侈&emsp;&emsp;第8杯，敬你口中的无奈&emsp;&emsp;第9杯，敬我们的初相识&emsp;&emsp;最后一杯，敬以后你是妳我是我\n  \n    Day of Commemoration：2025年8月9日\n\n  \n    \n  \n\n","categories":["随记"],"tags":["随记"]},{"title":"Hello World","url":"/2025/08/23/hello-world/","content":"\n  \n    \n      木兰花·拟古决绝词柬友\n\n    \n    \n      木兰花·拟古决绝词柬友纳兰性德纳兰性德〔清代〕\n\n人生若只如初见，何事秋风悲画扇。\n等闲变却故人心，却道故人心易变。\n骊山语罢清宵半，泪雨霖铃终不怨。\n何如薄幸锦衣郎，比翼连枝当日愿。\n\n\n    \n  \n\n\n","categories":["Hello World"],"tags":["Hello World"]},{"title":"爱心流水灯","url":"/2025/08/29/love-flow-lamp/","content":"前言今天要介绍的这款项目，是一个基于STC89C52RC单片机设计的多功能爱心形状LED流水灯系统。这个项目不仅能够实现多种绚丽的灯光效果，还可以作为装饰品或电子设计教学的工具。\n项目简介本项目采用了STC89C52RC单片机作为控制核心，精心设计并制作了一个爱心形状的LED显示装置。通过编写程序，我们实现了多种多样的灯光效果，使其既美观又实用。这个装置不仅可以用于装饰，还能作为教学工具，帮助初学者更好地理解单片机编程和电路设计。\n功能特点以下是一些主要的功能特点：\n\n全体LED同时闪烁：所有LED灯同时亮起和熄灭，营造出强烈的视觉冲击。\n顺时针流水灯效果：LED灯从左上方向右下方依次亮起，如同流水一般流动。\n逆时针流水灯效果：与顺时针效果相反，LED灯从右下方向左上方依次亮起。\n两侧同时流水效果：两侧的LED灯同时向中间流动，形成独特的光影效果。\n呼吸灯效果：LED灯的亮度逐渐变化，模拟呼吸时的明暗变化。\n随机闪烁效果：LED灯随机亮起和熄灭，带来意想不到的惊喜。\n\n除了上述效果，系统还支持多种其他效果，如交叉闪烁、心跳效果、波浪效果、跑马灯效果、渐变闪烁和螺旋效果。这些效果使得装置更加丰富多彩，能够满足不同的使用需求。\n项目结构GitHub仓库&#x2F;Gitee仓库项目的文件结构如下：\n├── Keil_Project/            # 程序源代码│   ├── main.c               # 主程序代码│   └── Objects/             # 编译生成文件├── PCB_Project/             # PCB设计文件│   ├── love-flow-lamp.PrjPcb       # PCB项目文件│   ├── love-flow-lamp.SchDoc       # 原理图文件│   ├── love-flow-lamp.PcbLib       # PCB库文件│   └── love-flow-lamp.PcbDoc       # PCB图纸文件└── 实物图片/                 # 成品展示\n\n开发环境本项目使用了以下开发工具和环境：\n\nIDE: Keil uVision 5\nPCB设计工具: Altium Designer\n编程语言: C语言\n目标单片机: STC89C52RC\n\n项目演示以下是项目实物图片：\n\n您可以在B站查看项目的详细演示视频：B站视频链接\n项目源码项目源码请参考GitHub仓库 Gitee仓库\n#include &lt;REGX52.H&gt;typedef unsigned char uchar;typedef unsigned int uint;void Delay_ms(unsigned int xms);void clock_wise(uint x);void anticlock_wise(uint x);void all_dance(void);void two_flanks(uint x);void breath_effect(void);void cross_flash(void);void random_flash(void);void heartbeat(void);void wave_effect(void);void marquee(void);void gradient_blink(void);void spiral(void);void rainbow_effect(void);void flash_center(void);static uint i;void main()&#123;    while(1)    &#123;           Delay_ms(500);        for (i = 60; i &gt; 0; i -= 10)        &#123;            clock_wise(i);        &#125;\t\tfor (i = 60; i &gt; 0; i -= 10)        &#123;            anticlock_wise(i);        &#125;\t\tDelay_ms(60);\t\tclock_wise(50);\t\tDelay_ms(60);\t\tanticlock_wise(50);        Delay_ms(60);        two_flanks(50);        Delay_ms(60);        breath_effect();    //呼吸效果\t\tDelay_ms(60);        cross_flash();      //交叉闪烁\t\tDelay_ms(60);        random_flash();     //随机闪烁\t\tDelay_ms(60);        heartbeat();        //心跳效果\t\twave_effect();      //波浪效果        Delay_ms(60);        marquee();          //跑马灯        Delay_ms(60);        gradient_blink();   //渐变闪烁        Delay_ms(60);        spiral();           //螺旋闪烁        Delay_ms(60);        rainbow_effect();   //彩虹渐变效果        Delay_ms(60);        flash_center();        Delay_ms(60);        all_dance();        Delay_ms(100);    &#125;&#125;//12m晶振频率，毫秒级延时void Delay_ms(uint xms)&#123;\tuchar i, j;\twhile(xms)\t&#123;\t\ti = 2;\t\tj = 239;\t\tdo\t\t&#123;\t\t\twhile (--j);\t\t&#125; while (--i);\t\txms--;\t&#125;&#125;//全体led闪烁void all_dance(void)&#123;\tP0=0xFF;P1=0xFF;P2=0xFF;P3=0xFF;\tDelay_ms(600);    P0=0x00;P1=0x00;P2=0x00;P3=0x00;\tDelay_ms(600);&#125;//顺时针流水灯void clock_wise(uint x)&#123;    P1=0x7F;Delay_ms(x);P1=0xBF;Delay_ms(x);P1=0xDF;Delay_ms(x);P1=0xEF;Delay_ms(x);    P1=0xF7;Delay_ms(x);P1=0xFB;Delay_ms(x);P1=0xFD;Delay_ms(x);P1=0xFE;Delay_ms(x);    P1=0xFF;Delay_ms(x);        P0=0xFE;Delay_ms(x);P0=0xFD;Delay_ms(x);P0=0xFB;Delay_ms(x);P0=0xF7;Delay_ms(x);    P0=0xEF;Delay_ms(x);P0=0xDF;Delay_ms(x);P0=0xBF;Delay_ms(x);P0=0x7F;Delay_ms(x);    P0=0xFF;Delay_ms(x);        P2=0x7F;Delay_ms(x);P2=0xBF;Delay_ms(x);P2=0xDF;Delay_ms(x);P2=0xEF;Delay_ms(x);    P2=0xF7;Delay_ms(x);P2=0xFB;Delay_ms(x);P2=0xFD;Delay_ms(x);P2=0xFE;Delay_ms(x);    P2=0xFF;Delay_ms(x);        P3=0x7f;Delay_ms(x);P3=0xBF;Delay_ms(x);P3=0xDF;Delay_ms(x);P3=0xEF;Delay_ms(x);    P3=0xF7;Delay_ms(x);P3=0xFB;Delay_ms(x);P3=0xFD;Delay_ms(x);P3=0xFE;Delay_ms(x);    P3=0xFF;Delay_ms(x);&#125;//逆时针流水灯void anticlock_wise(uint x)&#123;    P3=0xFE;Delay_ms(x);P3=0xFD;Delay_ms(x);P3=0xFB;Delay_ms(x);P3=0xF7;Delay_ms(x);    P3=0xEF;Delay_ms(x);P3=0xDF;Delay_ms(x);P3=0xBF;Delay_ms(x);P3=0x7F;Delay_ms(x);    P3=0xFF;Delay_ms(x);        P2=0xFE;Delay_ms(x);P2=0xFD;Delay_ms(x);P2=0xFB;Delay_ms(x);P2=0xF7;Delay_ms(x);    P2=0xEF;Delay_ms(x);P2=0xDF;Delay_ms(x);P2=0xBF;Delay_ms(x);P2=0x7F;Delay_ms(x);    P2=0xFF;Delay_ms(x);        P0=0x7F;Delay_ms(x);P0=0xBF;Delay_ms(x);P0=0xDF;Delay_ms(x);P0=0xEF;Delay_ms(x);    P0=0xF7;Delay_ms(x);P0=0xFB;Delay_ms(x);P0=0xFD;Delay_ms(x);P0=0xFE;Delay_ms(x);    P0=0xFF;Delay_ms(x);        P1=0xFE;Delay_ms(x);P1=0xFD;Delay_ms(x);P1=0xFB;Delay_ms(x);P1=0xF7;Delay_ms(x);    P1=0xEF;Delay_ms(x);P1=0xDF;Delay_ms(x);P1=0xBF;Delay_ms(x);P1=0x7F;Delay_ms(x);    P1=0xFF;Delay_ms(x);&#125;//两侧同时流水void two_flanks(uint x)&#123;\tP1=0x7F;P3=0xFE;Delay_ms(x);P1=0xBF;P3=0xFD;Delay_ms(x);P1=0xDF;P3=0xFB;Delay_ms(x);P1=0xEF;P3=0xF7;Delay_ms(x);\tP1=0xF7;P3=0xEF;Delay_ms(x);P1=0xFB;P3=0xDF;Delay_ms(x);P1=0xFD;P3=0xBF;Delay_ms(x);P1=0xFE;P3=0x7F;Delay_ms(x);\tP1=0xFF;P3=0xFF;Delay_ms(x);    P0=0xFD;P2=0xFD;Delay_ms(x);P0=0xFE;P2=0xFE;Delay_ms(x);P0=0xFB;P2=0xFB;Delay_ms(x);P0=0xF7;P2=0xF7;Delay_ms(x);\tP0=0xEF;P2=0xEF;Delay_ms(x);P0=0xDF;P2=0xDF;Delay_ms(x);P0=0xBF;P2=0xBF;Delay_ms(x);P0=0x7F;P2=0x7F;Delay_ms(x);\tP0=0xFF;P2=0xFF;Delay_ms(x);&#125;//呼吸灯效果（所有LED渐变亮度）void breath_effect(void) &#123;\tuchar i;    for(i=0; i&lt;5; i++) &#123;        P0=0xFF&lt;&lt;i; P1=0xFF&lt;&lt;i; P2=0xFF&lt;&lt;i; P3=0xFF&lt;&lt;i;        Delay_ms(80);    &#125;    for(i=5; i&gt;0; i--) &#123;        P0=0xFF&lt;&lt;i; P1=0xFF&lt;&lt;i; P2=0xFF&lt;&lt;i; P3=0xFF&lt;&lt;i;        Delay_ms(80);    &#125;&#125;//随机闪烁（随机位置LED闪烁）void random_flash(void) &#123;\tuchar i;    for(i=0; i&lt;8; i++) &#123;    P0 = ~(0x01 &lt;&lt; (i%8));     P1 = ~(0x01 &lt;&lt; ((i+2)%8));    P2 = ~(0x01 &lt;&lt; ((i+4)%8));    P3 = ~(0x01 &lt;&lt; ((i+6)%8));    Delay_ms(80);    &#125;&#125;//交叉闪烁（左右交替）void cross_flash(void) &#123;\tuchar i;    for(i=0; i&lt;4; i++) &#123;        P0=0xAA; P1=0xAA; P2=0x55; P3=0x55;  // 左半亮右半灭        Delay_ms(200);        P0=0x55; P1=0x55; P2=0xAA; P3=0xAA;  // 右半亮左半灭        Delay_ms(200);    &#125;    P0=0xFF; P1=0xFF; P2=0xFF; P3=0xFF;&#125;//心跳效果（快速闪烁三次）void heartbeat(void) &#123;\tuchar i;    for(i=0; i&lt;3; i++) &#123;        P0=0x00; P1=0x00; P2=0x00; P3=0x00;        Delay_ms(200);        P0=0xFF; P1=0xFF; P2=0xFF; P3=0xFF;        Delay_ms(200);    &#125;&#125;//波浪效果（从中心向四周扩散）void wave_effect(void) &#123;    uchar i;    for(i=0; i&lt;4; i++)&#123;        P0 = ~(0x18 &gt;&gt; i);  // 00011000 右移        P1 = ~(0x18 &gt;&gt; i);        P2 = ~(0x18 &lt;&lt; i);  // 00011000 左移        P3 = ~(0x18 &lt;&lt; i);        Delay_ms(120);    &#125;    P0=0xFF;P1=0xFF;P2=0xFF;P3=0xFF;&#125;//跑马灯效果（四端口循环追逐）void marquee(void) &#123;    uchar i;    for(i=0; i&lt;8; i++)&#123;        P0 = ~(0x80 &gt;&gt; i);         P1 = ~(0x80 &gt;&gt; (i+2)%8);        P2 = ~(0x80 &gt;&gt; (i+4)%8);        P3 = ~(0x80 &gt;&gt; (i+6)%8);        Delay_ms(150);    &#125;&#125;//渐变闪烁（不同频率闪烁）void gradient_blink(void) &#123;    uchar i;    for(i=0; i&lt;6; i++)&#123;        P0=0x00;P1=0xFF;P2=0x00;P3=0xFF;        Delay_ms(100 + i*20);        P0=0xFF;P1=0x00;P2=0xFF;P3=0x00;        Delay_ms(100 + i*20);    &#125;&#125;//螺旋效果（内外交替旋转）void spiral(void) &#123;    uchar patterns[] = &#123;0x7E,0xBD,0xDB,0xE7&#125;;\tuchar i;    for(i=0; i&lt;4; i++)&#123;        P0 = patterns[i];        P1 = patterns[(i+1)%4];        P2 = patterns[(i+2)%4];        P3 = patterns[(i+3)%4];        Delay_ms(200);    &#125;    P0=0xFF;P1=0xFF;P2=0xFF;P3=0xFF;&#125;//彩虹渐变效果（简单的颜色变化）void rainbow_effect(void) &#123;    uchar patterns[] = &#123;0xFF, 0x0C, 0xF3, 0x7E, 0x9F, 0x3F&#125;;    uchar i;    for(i=0; i&lt;6; i++)&#123;        P0 = patterns[i];        P1 = patterns[(i+1)%6];        P2 = patterns[(i+2)%6];        P3 = patterns[(i+3)%6];        Delay_ms(150);    &#125;    P0=0xFF;P1=0xFF;P2=0xFF;P3=0xFF;&#125;//闪烁中心点效果（四个端口的中间LED依次闪烁）void flash_center(void) &#123;    uchar i;    for(i=0; i&lt;3; i++)&#123;        P0=0x80; P1=0x00; P2=0x00; P3=0x00;        Delay_ms(200);        P0=0x00; P1=0x80; P2=0x00; P3=0x00;        Delay_ms(200);        P0=0x00; P1=0x00; P2=0x80; P3=0x00;        Delay_ms(200);        P0=0x00; P1=0x00; P2=0x00; P3=0x80;        Delay_ms(200);    &#125;    P0=0xFF;P1=0xFF;P2=0xFF;P3=0xFF;&#125;","categories":["电路设计"],"tags":["爱心流水灯","MCU","51","单片机"]},{"title":"多功能数字钟","url":"/2025/08/24/multifunctional-digital-clock/","content":"多功能数字钟项目简介本项目是一个基于普中51单片机试验仪(STC89C52RC MCU)的多功能数字钟设计，集成了时间显示、闹钟设置和温度检测等功能。通过使用LCD1602显示屏、DS1302实时时钟模块以及DS18B20温度传感器，实现了这些复杂的硬件交互。\n硬件框图\n电路原理图\n软件功能框图\n程序流程图\n效果演示多功能数字钟效果演示\n主要功能\n实时时间显示（年、月、日、时、分、秒及星期）\n闹钟设置功能\n温度显示功能\n秒表功能（启动&#x2F;暂停、清零）\n\n硬件连接\nLCD1602：\nRS -&gt; P2.6\nWR -&gt; P2.5\nEN -&gt; P2.7\nDataPort -&gt; P0\n\n\nDS1302：\nSCLK -&gt; P3.6\nIO -&gt; P3.4\nCE -&gt; P3.5\n\n\nDS18B20：\nIO -&gt; P3.7\n\n\nBEEP：\nBEEP -&gt; P1.5\n\n\nIndependent Key：\nKEY1 -&gt; P3.0\nKEY2 -&gt; P3.1\nKEY3 -&gt; P3.2\nKEY4 -&gt; P3.3\nKEY5 -&gt; P1.0\nKEY6 -&gt; P1.1\nKEY7 -&gt; P1.2\nKEY8 -&gt; P1.3\n\n\n\n软件功能闹钟功能\n通过AlarmTime数组设置闹钟时间。\n在CheckAlarm函数中检查当前时间是否与闹钟时间匹配，匹配时触发蜂鸣器。\n\n秒表功能\n使用StopwatchControl函数进行秒表的控制。\n显示秒表计时值，单位为分钟、秒和毫秒。\n开始&#x2F;暂停秒表计时，清零秒表示数。\n\n温度显示功能\n初始化DS18B20，发送转换命令并读取温度。\n使用DS18B20_ReadT函数读取温度数据，并将其显示在LCD1602上。\n\n按键功能\n按键功能通过Key函数读取键码。\n模式切换、时间设置、秒表控制等功能通过按键触发。\n按键具体功能：\nKEY1 -&gt; 进入&#x2F;退出时间设置模式\nKEY2 -&gt; 选择调整的位\nKEY3 -&gt; 数值加1\nKEY4 -&gt; 数值减1\nKEY5 -&gt; 时钟&#x2F;秒表&#x2F;闹钟设置模式切换\nKEY6 -&gt; 开始&#x2F;暂停秒表计时\nKEY7 -&gt; 清零秒表计时\nKEY8 -&gt; 暂时未使用\n\n\n\n定时器功能\n使用T0定时器实现100ms中断，用于控制秒表计时和闪烁效果。\n\n代码结构以下为本项目中主要的函数声明及其实现：\n\nLCD1602：\n\nLCD_Init：初始化LCD1602显示屏。\nLCD_WriteCommand：向LCD1602写入命令。\nLCD_WriteData：向LCD1602写入数据。\nLCD_SetCursor：设置LCD1602光标位置。\nLCD_ShowChar：在指定位置显示一个字符。\nLCD_ShowString：在指定位置显示字符串。\nLCD_ShowNum：在指定位置显示数字。\nLCD_Pow：用于LCD1602的乘方运算。\n\n\nDS1302：\n\nDS1302_Init：初始化DS1302实时时钟模块。\nDS1302_WriteByte：向DS1302写入一个字节。\nDS1302_ReadByte：从DS1302读取一个字节。\nDS1302_SetTime：设置DS1302的时间。\nDS1302_ReadTime：从DS1302读取时间。\n\n\nDS18B20：\n\nDS18B20_Init：初始化DS18B20温度传感器。\nDS18B20_ConvertT：转换温度。\nDS18B20_ReadT：读取温度。\n\n\n单总线：\n\nOneWire_Init：初始化单总线。\nOneWire_SendBit：发送一位数据。\nOneWire_ReceiveBit：接收一位数据。\nOneWire_SendByte：发送一个字节数据。\nOneWire_ReceiveByte：接收一个字节数据。\n\n\n时间设置：\n\nTimeSet：用于时间设置功能。\nTimeShow：用于时间显示功能。\n\n\n秒表：\n\nStopwatchControl：用于秒表控制。\nShowStopwatch：用于显示秒表示数。\n\n\n蜂鸣器：\n\nTimer0_Routine：定时器中断服务程序，控制蜂鸣器鸣叫和秒表示数更新。\n\n\n\n注意事项\n请确保所有硬件连接正确无误。\n在实际使用中，可能需要根据具体的单片机型号和开发环境进行适当的调整。\n温度传感器DS18B20的读取可能需要根据实际温度范围和精度进行优化。\n\n编译与烧录使用Keil uVision或其他兼容的51单片机开发环境进行编译，将生成的HEX文件烧录到单片机中进行测试。\n完整程序#include &lt;REGX52.H&gt;#include &quot;intrins.h&quot;//1602引脚配置#define LCD_RS P2_6#define LCD_RW P2_5#define LCD_EN P2_7#define LCD_DataPort P0//1302引脚配置#define DS1302_SCLK P3_6#define DS1302_IO P3_4#define DS1302_CE P3_5//18B20引脚配置#define OneWire_DQ P3_7//1302寄存器写入地址/指令定义#define DS1302_SECOND\t\t0x80#define DS1302_MINUTE\t\t0x82#define DS1302_HOUR\t\t\t0x84#define DS1302_DATE\t\t\t0x86#define DS1302_MONTH\t\t0x88#define DS1302_DAY\t\t\t0x8A#define DS1302_YEAR\t\t\t0x8C#define DS1302_WP\t\t\t0x8E//独立按键函数声明unsigned char Key();//延时函数声明void Delay(unsigned int xms);//T0定时器初始化函数声明void Timer0Init(void);//闹钟功能函数声明void CheckAlarm();//1302函数声明void DS1302_Init(void);void DS1302_WriteByte(unsigned char Command,Data);unsigned char DS1302_ReadByte(unsigned char Command);void DS1302_SetTime(void);void DS1302_ReadTime(void);//18B20函数声明void DS18B20_ConvertT(void);float DS18B20_ReadT(void);void DS18B20_Init(void);//单总线函数声明unsigned char OneWire_Init(void);void OneWire_SendBit(unsigned char Bit);unsigned char OneWire_ReceiveBit(void);void OneWire_SendByte(unsigned char Byte);unsigned char OneWire_ReceiveByte(void);//DS18B20指令#define DS18B20_SKIP_ROM\t\t\t0xCC#define DS18B20_CONVERT_T\t\t\t0x44#define DS18B20_READ_SCRATCHPAD \t0xBE//时间数组，索引0~6分别为年、月、日、时、分、秒、星期，设置为有符号的便于&lt;0的判断char DS1302_Time[]=&#123;25,01,01,11,31,55,3&#125;;//闹钟时间设置char AlarmTime[] = &#123;25,01,01,11,31,59,3&#125;; //年、月、日、 时、分、秒//标志全局变量unsigned char KeyNum,MODE,TimeSetSelect,TimeSetFlashFlag,AlarmFlag,BuzzerState,BuzzerCount,StopwatchMode,StopwatchState;unsigned int StopwatchTime = 0;float T;//温度#define Buzzer P1_5//星期计算函数声明unsigned char CalculateWeekday(int year, int month, int day);//1602函数声明void LCD_Init();void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char);void LCD_ShowString(unsigned char Line,unsigned char Column,char *String);void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length);int LCD_Pow(int X,int Y);//时间函数声明void TimeSet(char* TimeArray,unsigned char* SelectPtr);//时间设置功能void TimeShow(void);//时间显示功能//秒表功能函数声明void ShowStopwatch();// 显示秒表计时值void StopwatchControl();//秒表按键功能 //温度显示函数声明void Show_Temperature();void main()&#123;\tLCD_Init();\tDS1302_Init();\tDS18B20_ConvertT();\t\tDS18B20_Init();\t\tTimer0Init();\tLCD_ShowString(1,1,&quot;  -  -  &quot;);//静态字符初始化显示\tLCD_ShowString(2,1,&quot;  :  :  &quot;);\tDS1302_Time[6] = CalculateWeekday(DS1302_Time[0], DS1302_Time[1], DS1302_Time[2]);\tDS1302_SetTime();\t\twhile(1)\t&#123;\t\tKeyNum=Key();//读取键码\t\tif(KeyNum==1)//按键1按下\t\t&#123;\t\t\tif(MODE==0)&#123;MODE=1;TimeSetSelect=0;&#125;//功能切换\t\t\telse if(MODE==1)&#123;MODE=0;DS1302_SetTime();&#125;\t\t\telse if(MODE==3)&#123;MODE=0;&#125;\t\t&#125;\t\tif(KeyNum==5)&#123;\t\t\tif(MODE==0)&#123;\t\t\t\tMODE=2;\t\t\t\tLCD_Init(); // 切换到秒表模式时初始化LCD\t\t\t\tLCD_ShowString(1,1,&quot;Stopwatch&quot;);\t\t\t\tStopwatchTime = 0; // 重置秒表时间\t\t\t\tStopwatchState = 0; // 重置秒表状态\t\t\t&#125;\t\t\telse if(MODE==2)&#123;\t\t\t\tMODE=3;\t\t\t\tLCD_Init();\t\t\t\tLCD_ShowString(1,1,&quot;  -  -  &quot;);\t\t\t\tLCD_ShowString(2,1,&quot;  :  :  &quot;);\t\t\t&#125;\t\t\telse if(MODE == 3)\t\t\t&#123;\t\t\t\tMODE=0;\t\t\t\tLCD_Init();\t\t\t\tLCD_ShowString(1,1,&quot;  -  -  &quot;);\t\t\t\tLCD_ShowString(2,1,&quot;  :  :  &quot;);\t\t\t&#125;\t\t\t\t\t&#125;\t\tswitch(MODE)//根据不同的功能执行不同的函数\t\t&#123;\t\t\tcase 0:TimeShow();CheckAlarm();Show_Temperature();break;\t\t\tcase 1:TimeSet(DS1302_Time,&amp;TimeSetSelect);break;\t\t\tcase 2:StopwatchControl();break;\t\t\tcase 3:TimeSet(AlarmTime,&amp;TimeSetSelect);LCD_ShowString(2, 10, &quot;W:&quot;);LCD_ShowString(1, 10, &quot;SETTING&quot;);break;\t\t&#125;\t\tif (BuzzerState) &#123;            BuzzerCount++;            if (BuzzerCount &gt;= 50) &#123; // 蜂鸣器鸣叫 5 秒（100ms * 10）                BuzzerState = 0;    // 关闭蜂鸣器                BuzzerCount = 0;\t\t\t\tBuzzer = 0;            &#125;            Buzzer = !Buzzer;\t\t\tDelay(5);\t\t\tBuzzer = !Buzzer;\t\t\tDelay(5);\t\t\tBuzzer = !Buzzer;\t\t\tDelay(5);// 蜂鸣器状态取反        &#125; else &#123;            Buzzer = 0; // 关闭蜂鸣器        &#125;&#125;&#125;void Show_Temperature()&#123;\tDS18B20_ConvertT();\t//转换温度\tT=DS18B20_ReadT();\t//读取温度\t//Delay(500);\tif(T&lt;0)\t\t\t\t//如果温度小于0\t&#123;\t\tLCD_ShowChar(1,10,&#x27;-&#x27;);\t//显示负号\t\tT=-T;\t\t\t//将温度变为正数\t&#125;\telse\t\t\t\t//如果温度大于等于0\t&#123;\t\tLCD_ShowChar(1,10,&#x27;+&#x27;);\t//显示正号\t&#125;\tLCD_ShowNum(1,11,(unsigned int)T,2);\t\t//显示温度整数部分\tLCD_ShowChar(1,13,&#x27;.&#x27;);\t\t//显示小数点\tLCD_ShowNum(1,14,(unsigned int)(T*100)%100,2);//显示温度小数部分&#125;//秒表按键功能void StopwatchControl() &#123;     // 按键2：开始/暂停秒表    if (KeyNum == 6) &#123;        StopwatchState = !StopwatchState;    &#125;    // 按键3：清零秒表    if (KeyNum == 7) &#123;        StopwatchTime = 0;        StopwatchState = 0;    &#125;    // 显示秒表计时值    ShowStopwatch();&#125;// 显示秒表计时值void ShowStopwatch() &#123;    unsigned int seconds = StopwatchTime / 1000; // 计算秒    unsigned int milliseconds = StopwatchTime % 1000; // 计算毫秒    LCD_ShowNum(2, 1, seconds / 60, 2); // 显示分钟    LCD_ShowChar(2, 3, &#x27;:&#x27;);           // 显示冒号    LCD_ShowNum(2, 4, seconds % 60, 2); // 显示秒    LCD_ShowChar(2, 6, &#x27;.&#x27;);           // 显示小数点    LCD_ShowNum(2, 7, milliseconds / 10, 2); // 显示毫秒（取前两位）&#125;void TimeShow(void)//时间显示功能&#123;\t\tDS1302_ReadTime();//读取时间\tLCD_ShowNum(1,1,DS1302_Time[0],2);//显示年\tLCD_ShowNum(1,4,DS1302_Time[1],2);//显示月\tLCD_ShowNum(1,7,DS1302_Time[2],2);//显示日\tLCD_ShowNum(2,1,DS1302_Time[3],2);//显示时\tLCD_ShowNum(2,4,DS1302_Time[4],2);//显示分\tLCD_ShowNum(2,7,DS1302_Time[5],2);//显示秒\tLCD_ShowString(2, 10, &quot;W:&quot;);          // 显示星期 \tLCD_ShowNum(2, 12, DS1302_Time[6], 1); // 显示星期值&#125;void TimeSet(char* TimeArray,unsigned char* SelectPtr)//时间设置功能&#123;\tif(KeyNum==2)//按键2按下\t&#123;\t\t(*SelectPtr)++;//设置选择位加1\t\t*SelectPtr%=7;//越界清零\t&#125;\tif(KeyNum==3)//按键3按下\t&#123;\t\tTimeArray[*SelectPtr]++;//时间设置位数值加1\t\t \t\tif(TimeArray[0]&gt;99)&#123;TimeArray[0]=0;&#125;//年越界判断\t\tif(TimeArray[1]&gt;12)&#123;TimeArray[1]=1;&#125;//月越界判断\t\tif( TimeArray[1]==1 || TimeArray[1]==3 || TimeArray[1]==5 || TimeArray[1]==7 || \t\t\tTimeArray[1]==8 || TimeArray[1]==10 || TimeArray[1]==12)//日越界判断\t\t&#123;\t\t\tif(TimeArray[2]&gt;31)&#123;TimeArray[2]=1;&#125;//大月\t\t&#125;\t\telse if(TimeArray[1]==4 || TimeArray[1]==6 || TimeArray[1]==9 || TimeArray[1]==11)\t\t&#123;\t\t\tif(TimeArray[2]&gt;30)&#123;TimeArray[2]=1;&#125;//小月\t\t&#125;\t\telse if(TimeArray[1]==2)\t\t&#123;\t\t\tif(TimeArray[0]%4==0)\t\t\t&#123;\t\t\t\tif(TimeArray[2]&gt;29)&#123;TimeArray[2]=1;&#125;//闰年2月\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif(TimeArray[2]&gt;28)&#123;TimeArray[2]=1;&#125;//平年2月\t\t\t&#125;\t\t&#125;\t\tTimeArray[6] = CalculateWeekday(TimeArray[0], TimeArray[1], TimeArray[2]);//更新星期\t\tif(TimeArray[3]&gt;23)&#123;TimeArray[3]=0;&#125;//时越界判断\t\tif(TimeArray[4]&gt;59)&#123;TimeArray[4]=0;&#125;//分越界判断\t\tif(TimeArray[5]&gt;59)&#123;TimeArray[5]=0;&#125;//秒越界判断\t\tif(TimeArray[6]&gt;6)&#123;TimeArray[6]=0;&#125;//星期越界判断\t&#125;\tif(KeyNum==4)//按键4按下\t&#123;\t\tTimeArray[*SelectPtr]--;//时间设置位数值减1\t\tif(TimeArray[0]&lt;0)&#123;TimeArray[0]=99;&#125;//年越界判断\t\tif(TimeArray[1]&lt;1)&#123;TimeArray[1]=12;&#125;//月越界判断\t\tif( TimeArray[1]==1 || TimeArray[1]==3 || TimeArray[1]==5 || TimeArray[1]==7 || \t\t\tTimeArray[1]==8 || TimeArray[1]==10 || TimeArray[1]==12)//日越界判断\t\t&#123;\t\t\tif(TimeArray[2]&lt;1)&#123;TimeArray[2]=31;&#125;//大月\t\t\tif(TimeArray[2]&gt;31)&#123;TimeArray[2]=1;&#125;\t\t&#125;\t\telse if(TimeArray[1]==4 || TimeArray[1]==6 || TimeArray[1]==9 || TimeArray[1]==11)\t\t&#123;\t\t\tif(TimeArray[2]&lt;1)&#123;TimeArray[2]=30;&#125;//小月\t\t\tif(TimeArray[2]&gt;30)&#123;TimeArray[2]=1;&#125;\t\t&#125;\t\telse if(TimeArray[1]==2)\t\t&#123;\t\t\tif(TimeArray[0]%4==0)\t\t\t&#123;\t\t\t\tif(TimeArray[2]&lt;1)&#123;TimeArray[2]=29;&#125;//闰年2月\t\t\t\tif(TimeArray[2]&gt;29)&#123;TimeArray[2]=1;&#125;\t\t\t&#125;\t\t\telse\t\t\t&#123;\t\t\t\tif(TimeArray[2]&lt;1)&#123;TimeArray[2]=28;&#125;//平年2月\t\t\t\tif(TimeArray[2]&gt;28)&#123;TimeArray[2]=1;&#125;\t\t\t&#125;\t\t&#125;\t\tif(TimeArray[3]&lt;0)&#123;TimeArray[3]=23;&#125;//时越界判断\t\tif(TimeArray[4]&lt;0)&#123;TimeArray[4]=59;&#125;//分越界判断\t\tif(TimeArray[5]&lt;0)&#123;TimeArray[5]=59;&#125;//秒越界判断\t\tif(TimeArray[6]&lt;0)&#123;TimeArray[6]=6;&#125;//星期越界判断\t\tTimeArray[6] = CalculateWeekday(TimeArray[0], TimeArray[1], TimeArray[2]);\t&#125;\t//更新显示，根据TimeSetSelect和TimeSetFlashFlag判断可完成闪烁功能\tif(*SelectPtr==0 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(1,1,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(1,1,TimeArray[0],2);&#125;\tif(*SelectPtr==1 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(1,4,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(1,4,TimeArray[1],2);&#125;\tif(*SelectPtr==2 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(1,7,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(1,7,TimeArray[2],2);&#125;\tif(*SelectPtr==3 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(2,1,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(2,1,TimeArray[3],2);&#125;\tif(*SelectPtr==4 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(2,4,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(2,4,TimeArray[4],2);&#125;\tif(*SelectPtr==5 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(2,7,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(2,7,TimeArray[5],2);&#125;\tif(*SelectPtr==6 &amp;&amp; TimeSetFlashFlag==1)&#123;LCD_ShowString(2,12,&quot;  &quot;);&#125;\telse &#123;LCD_ShowNum(2,12,TimeArray[6],1);&#125;&#125;void Timer0_Routine() interrupt 1&#123;\tstatic unsigned int T0Count;\tstatic unsigned char station_toggle;\tTL0 = 0x18;\t\t//设置定时初值\tTH0 = 0xFC;\t\t//设置定时初值\tT0Count++;\tif(T0Count&gt;=100)//每100ms进入一次\t&#123;\t\t\tT0Count=0;\t\tstation_toggle++;\t\tif (station_toggle&gt;=4)\t\t&#123;\t\t\tstation_toggle = 0;\t\t\tTimeSetFlashFlag=!TimeSetFlashFlag;//闪烁标志位取反\t\t&#125;\t\tif (StopwatchState) &#123;            StopwatchTime += 100; // 增加 100ms        &#125;\t&#125;&#125;//LCD1602写命令void LCD_WriteCommand(unsigned char Command)&#123;\tLCD_RS=0;\tLCD_RW=0;\tLCD_DataPort=Command;\tLCD_EN=1;\tDelay(1);\tLCD_EN=0;\tDelay(1);&#125;//LCD1602写数据void LCD_WriteData(unsigned char Data)&#123;\tLCD_RS=1;\tLCD_RW=0;\tLCD_DataPort=Data;\tLCD_EN=1;\tDelay(1);\tLCD_EN=0;\tDelay(1);&#125;//LCD1602设置光标位置void LCD_SetCursor(unsigned char Line,unsigned char Column)&#123;\tif(Line==1)\t&#123;\t\tLCD_WriteCommand(0x80|(Column-1));\t&#125;\telse if(Line==2)\t&#123;\t\tLCD_WriteCommand(0x80|(Column-1+0x40));\t&#125;&#125;//LCD1602初始化函数void LCD_Init()&#123;\tLCD_WriteCommand(0x38);//八位数据接口，两行显示，5*7点阵\tLCD_WriteCommand(0x0c);//显示开，光标关，闪烁关\tLCD_WriteCommand(0x06);//数据读写操作后，光标自动加一，画面不动\tLCD_WriteCommand(0x01);//光标复位，清屏&#125;//在LCD1602指定位置上显示一个字符void LCD_ShowChar(unsigned char Line,unsigned char Column,char Char)&#123;\tLCD_SetCursor(Line,Column);\tLCD_WriteData(Char);&#125;//在LCD1602指定位置开始显示所给字符串void LCD_ShowString(unsigned char Line,unsigned char Column,char *String)&#123;\tunsigned char i;\tLCD_SetCursor(Line,Column);\tfor(i=0;String[i]!=&#x27;\\0&#x27;;i++)\t&#123;\t\tLCD_WriteData(String[i]);\t&#125;&#125;// 在LCD1602指定位置开始显示所给数字void LCD_ShowNum(unsigned char Line,unsigned char Column,unsigned int Number,unsigned char Length)&#123;\tunsigned char i;\tLCD_SetCursor(Line,Column);\tfor(i=Length;i&gt;0;i--)\t&#123;\t\tLCD_WriteData(Number/LCD_Pow(10,i-1)%10+&#x27;0&#x27;);\t&#125;&#125;//LCD1602乘方运算int LCD_Pow(int X,int Y)&#123;\tunsigned char i;\tint Result=1;\tfor(i=0;i&lt;Y;i++)\t&#123;\t\tResult*=X;\t&#125;\treturn Result;&#125;//独立按键函数实现unsigned char Key()&#123;\tunsigned char KeyNumber=0;\tif(P3_0==0)&#123;Delay(20);while(P3_0==0);Delay(20);KeyNumber=1;&#125;\tif(P3_1==0)&#123;Delay(20);while(P3_1==0);Delay(20);KeyNumber=2;&#125;\tif(P3_2==0)&#123;Delay(20);while(P3_2==0);Delay(20);KeyNumber=3;&#125;\tif(P3_3==0)&#123;Delay(20);while(P3_3==0);Delay(20);KeyNumber=4;&#125;\tif(P1_0==0)&#123;Delay(20);while(P1_0==0);Delay(20);KeyNumber=5;&#125;\tif(P1_1==0)&#123;Delay(20);while(P1_1==0);Delay(20);KeyNumber=6;&#125;\tif(P1_2==0)&#123;Delay(20);while(P1_2==0);Delay(20);KeyNumber=7;&#125;\tif(P1_3==0)&#123;Delay(20);while(P1_3==0);Delay(20);KeyNumber=8;&#125;\treturn KeyNumber;&#125;//延时函数实现void Delay(unsigned int xms)&#123;\tunsigned char i, j;\twhile(xms--)\t&#123;\t\ti = 2;\t\tj = 239;\t\tdo\t\t&#123;\t\t\twhile (--j);\t\t&#125; while (--i);\t&#125;&#125;//T0定时器初始化函数实现void Timer0Init(void)&#123;\tTMOD &amp;= 0xF0;\t\t//设置定时器模式\tTMOD |= 0x01;\t\t//设置定时器模式\tTL0 = 0x18;\t\t//设置定时初值\tTH0 = 0xFC;\t\t//设置定时初值\tTF0 = 0;\t\t//清除TF0标志\tTR0 = 1;\t\t//定时器0开始计时\tET0=1;\tEA=1;\tPT0=0;&#125;//DS1302初始化void DS1302_Init(void)&#123;\tDS1302_CE=0;\tDS1302_SCLK=0;&#125;//DS1302写一个字节void DS1302_WriteByte(unsigned char Command,Data)&#123;\tunsigned char i;\tDS1302_CE=1;\tfor(i=0;i&lt;8;i++)\t&#123;\t\tDS1302_IO=Command&amp;(0x01&lt;&lt;i);\t\tDS1302_SCLK=1;\t\tDS1302_SCLK=0;\t&#125;\tfor(i=0;i&lt;8;i++)\t&#123;\t\tDS1302_IO=Data&amp;(0x01&lt;&lt;i);\t\tDS1302_SCLK=1;\t\tDS1302_SCLK=0;\t&#125;\tDS1302_CE=0;&#125;//DS1302读一个字节unsigned char DS1302_ReadByte(unsigned char Command)&#123;\tunsigned char i,Data=0x00;\tCommand|=0x01;\t//将指令转换为读指令\tDS1302_CE=1;\tfor(i=0;i&lt;8;i++)\t&#123;\t\tDS1302_IO=Command&amp;(0x01&lt;&lt;i);\t\tDS1302_SCLK=0;\t\tDS1302_SCLK=1;\t&#125;\tfor(i=0;i&lt;8;i++)\t&#123;\t\tDS1302_SCLK=1;\t\tDS1302_SCLK=0;\t\tif(DS1302_IO)&#123;Data|=(0x01&lt;&lt;i);&#125;\t&#125;\tDS1302_CE=0;\tDS1302_IO=0;\t//读取后将IO设置为0，否则读出的数据会出错\treturn Data;&#125;//DS1302设置时间  void DS1302_SetTime(void)&#123;\tDS1302_WriteByte(DS1302_WP,0x00);\tDS1302_WriteByte(DS1302_YEAR,DS1302_Time[0]/10*16+DS1302_Time[0]%10);//十进制转BCD码后写入\tDS1302_WriteByte(DS1302_MONTH,DS1302_Time[1]/10*16+DS1302_Time[1]%10);\tDS1302_WriteByte(DS1302_DATE,DS1302_Time[2]/10*16+DS1302_Time[2]%10);\tDS1302_WriteByte(DS1302_HOUR,DS1302_Time[3]/10*16+DS1302_Time[3]%10);\tDS1302_WriteByte(DS1302_MINUTE,DS1302_Time[4]/10*16+DS1302_Time[4]%10);\tDS1302_WriteByte(DS1302_SECOND,DS1302_Time[5]/10*16+DS1302_Time[5]%10);\tDS1302_WriteByte(DS1302_DAY,DS1302_Time[6]/10*16+DS1302_Time[6]%10);\tDS1302_WriteByte(DS1302_WP,0x80);&#125;//DS1302读取时间void DS1302_ReadTime(void)&#123;\tunsigned char Temp;\tTemp=DS1302_ReadByte(DS1302_YEAR);\tDS1302_Time[0]=Temp/16*10+Temp%16;//BCD码转十进制后读取\tTemp=DS1302_ReadByte(DS1302_MONTH);\tDS1302_Time[1]=Temp/16*10+Temp%16;\tTemp=DS1302_ReadByte(DS1302_DATE);\tDS1302_Time[2]=Temp/16*10+Temp%16;\tTemp=DS1302_ReadByte(DS1302_HOUR);\tDS1302_Time[3]=Temp/16*10+Temp%16;\tTemp=DS1302_ReadByte(DS1302_MINUTE);\tDS1302_Time[4]=Temp/16*10+Temp%16;\tTemp=DS1302_ReadByte(DS1302_SECOND);\tDS1302_Time[5]=Temp/16*10+Temp%16;\tTemp=DS1302_ReadByte(DS1302_DAY);\tDS1302_Time[6]=Temp/16*10+Temp%16;&#125;//闹钟功能函数实现void CheckAlarm() &#123;    if (DS1302_Time[0] == AlarmTime[0] &amp;&amp;         DS1302_Time[1] == AlarmTime[1] &amp;&amp;         DS1302_Time[2] == AlarmTime[2] &amp;&amp;\t\tDS1302_Time[3] == AlarmTime[3] &amp;&amp;\t\tDS1302_Time[4] == AlarmTime[4] &amp;&amp;\t\tDS1302_Time[5] == AlarmTime[5] &amp;&amp;\t\tDS1302_Time[6] == AlarmTime[6]) &#123;        AlarmFlag = 1; // 触发闹钟\t\tBuzzerState = 1;\t\t&#125;else &#123;        AlarmFlag = 0; // 关闭闹钟    &#125;&#125;//18B20函数实现void DS18B20_Init(void)&#123;\tDS18B20_ConvertT();\t\t//上电先转换一次温度，防止第一次读数据错误\tDelay(1000);\t\t\t//等待转换完成&#125;//转换温度void DS18B20_ConvertT(void)&#123;\tOneWire_Init();\tOneWire_SendByte(DS18B20_SKIP_ROM);\tOneWire_SendByte(DS18B20_CONVERT_T);&#125;//读取温度float DS18B20_ReadT(void)&#123;\tunsigned char TLSB,TMSB;\tint Temp;\tfloat T;\tOneWire_Init();\tOneWire_SendByte(DS18B20_SKIP_ROM);\tOneWire_SendByte(DS18B20_READ_SCRATCHPAD);\tTLSB=OneWire_ReceiveByte();\tTMSB=OneWire_ReceiveByte();\tTemp=(TMSB&lt;&lt;8)|TLSB;\tT=Temp/16.0;\treturn T;&#125;//单总线函数实现unsigned char OneWire_Init(void)&#123;\tunsigned char i;\tunsigned char AckBit;\tOneWire_DQ=1;\tOneWire_DQ=0;\ti = 247;while (--i);\t\t//Delay 500us\tOneWire_DQ=1;\ti = 32;while (--i);\t\t\t//Delay 70us\tAckBit=OneWire_DQ;\ti = 247;while (--i);\t\t//Delay 500us\treturn AckBit;&#125;//单总线发送一位void OneWire_SendBit(unsigned char Bit)&#123;\tunsigned char i;\tOneWire_DQ=0;\ti = 4;while (--i);\t\t\t//Delay 10us\tOneWire_DQ=Bit;\ti = 24;while (--i);\t\t\t//Delay 50us\tOneWire_DQ=1;&#125;//单总线接收一位unsigned char OneWire_ReceiveBit(void)&#123;\tunsigned char i;\tunsigned char Bit;\tOneWire_DQ=0;\ti = 2;while (--i);\t\t\t//Delay 5us\tOneWire_DQ=1;\ti = 2;while (--i);\t\t\t//Delay 5us\tBit=OneWire_DQ;\ti = 24;while (--i);\t\t\t//Delay 50us\treturn Bit;&#125;//单总线发送一个字节void OneWire_SendByte(unsigned char Byte)&#123;\tunsigned char i;\tfor(i=0;i&lt;8;i++)\t&#123;\t\tOneWire_SendBit(Byte&amp;(0x01&lt;&lt;i));\t&#125;&#125;//单总线接收一个字节unsigned char OneWire_ReceiveByte(void)&#123;\tunsigned char i;\tunsigned char Byte=0x00;\tfor(i=0;i&lt;8;i++)\t&#123;\t\tif(OneWire_ReceiveBit())&#123;Byte|=(0x01&lt;&lt;i);&#125;\t&#125;\treturn Byte;&#125;//星期计算函数实现unsigned char CalculateWeekday(int year, int month, int day) &#123;\tunsigned char weekday;    if (month &lt; 3) &#123;        month += 12;        year--;    &#125;    weekday = (day + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400) % 7;    return (weekday + 1);&#125;","categories":["电路设计"],"tags":["MCU","51","单片机","数字钟"]},{"title":"VS Code 配置 C/C++ 开发环境 (MinGW-w64) 终极指南","url":"/2025/08/26/setup-vscode-mingw-cpp-env/","content":"Visual Studio Code (VS Code) 凭借其轻量、强大和高度可扩展的特性，已成为许多开发者的首选代码编辑器。本文将一步步带你从零开始，在 Windows 系统上使用 VS Code 和 MinGW-w64 工具链，搭建一个完整、高效的 C&#x2F;C++ 开发与调试环境。\n\n\n准备工作在开始之前，请确保你已经完成了以下准备：\n\n安装 Visual Studio Code: 如果你还没有安装，请前往 VS Code 官网 下载并安装。\n一个稳定的网络连接: 我们需要下载一些工具和插件。\n\n第一步：安装 MinGW-w64 编译器MinGW-w64 是一个在 Windows 上提供原生 GCC 工具链（包括 C&#x2F;C++ 编译器 gcc 和 g++）的项目。我们提供两种安装方式，你可以根据自己的偏好选择其一。\n方式一：使用 MSYS2 安装 (推荐)这种方式的好处是可以通过包管理器 pacman 方便地更新和管理工具链。\n\n下载 MSYS2: 访问 MSYS2 官网，下载并运行最新的安装程序。按照默认设置一路“下一步”即可。\n\n更新 MSYS2 包数据库: 安装完成后，从开始菜单找到并打开 “MSYS2 UCRT64” 终端。执行以下命令更新包数据库和基础包（如果提示关闭窗口，请照做，然后重新打开终端继续执行）。\npacman -Syupacman -Su\n\n安装 MinGW-w64 工具链: 在同一个终端中，执行以下命令来安装完整的 C&#x2F;C++ 编译器工具链。\npacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain\n安装过程中会提示确认，按回车键默认全部安装即可。\n\n\n方式二：下载二进制包 (更直接)这种方式无需安装额外的管理器，下载解压即可，非常纯粹。\nⅠ. 我们推荐使用 WinLibs 提供的编译好的包。\n下载 WinLibs: 访问 WinLibs 官网 的下载页面。\n找到最新的 GCC + GDB 版本，选择 UCRT runtime 的 Win64 版本进行下载（通常是一个 .zip 压缩包）。\n解压文件: 下载完成后，将压缩包解压到一个没有中文和空格的稳定路径。强烈推荐直接解压到 C: 盘根目录，这样解压后的文件夹路径就是 C:\\mingw64。\n\nⅡ. Github 开源的二进制包\n下载二进制包: 访问 Github 。\n找到Releases：Releases 页面。\n在Releases中找到最新的版本的Assets，选择 X86-64 的 posix-seh-ucrt-rt 版本进行下载（通常是一个 .7z 压缩包）。\n解压文件: 下载完成后，将压缩包解压到一个没有中文和空格的稳定路径。\n\n第二步：配置系统环境变量为了让 VS Code 和系统能够找到 gcc, g++, gdb 等命令，我们需要将编译器的路径添加到系统的 PATH 环境变量中。\n\n找到编译器路径: 根据你选择的安装方式，路径会有所不同。\n\n方式一 (MSYS2): 路径通常为 C:\\msys64\\ucrt64\\bin 和 C:\\msys64\\usr\\bins\n方式二 (二进制包): 路径为你解压的路径下的 bin 文件夹，例如 C:\\mingw64\\bin\n\n\n添加到环境变量:\n\n在 Windows 搜索栏中搜索“编辑系统环境变量”并打开。\n点击“环境变量…”。\n在“系统变量”区域找到并双击 Path。\n点击“新建”，然后将你上面找到的对应路径粘贴进去。\n一路点击“确定”保存所有窗口。\n\n\n验证安装: 打开一个新的 CMD 或 PowerShell 窗口（注意是新的！），分别输入以下命令：\ngcc --versiong++ --versiongdb --version\n如果三个命令都能正确显示版本号，说明你的编译器和环境变量已经配置成功！\n\n\n第三步：安装 VS Code 插件打开 VS Code，点击左侧的扩展图标，搜索并安装由 Microsoft 官方提供的 C&#x2F;C++ Extension Pack。它包含了 C&#x2F;C++ 智能提示、调试等核心功能。\n第四步：创建并配置你的第一个项目现在，让我们来创建一个 “Hello, World!” 项目来验证所有配置。\n\n创建项目文件夹: 在你喜欢的位置创建一个新文件夹，例如 HelloWorld，然后在 VS Code 中打开这个文件夹。\n\n创建源文件: 在 HelloWorld 文件夹中新建一个文件，命名为 main.cpp，并输入以下代码：\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;int main()&#123;    std::vector&lt;std::string&gt; msg &#123;&quot;Hello&quot;, &quot;C++&quot;, &quot;World&quot;, &quot;from&quot;, &quot;VS Code&quot;, &quot;and&quot;, &quot;MinGW-w64!&quot;&#125;;    for (const std::string&amp; word : msg)    &#123;        std::cout &lt;&lt; word &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;    return 0;&#125;\n\n配置智能提示 (c_cpp_properties.json):\n\n按下 Ctrl + Shift + P 打开命令面板，输入 C/C++: Edit Configurations (UI)。\n在 编译器路径 (Compiler path) 配置项中，VS Code 通常会自动检测到你配置好的 g++.exe。如果未检测到，请手动选择它的完整路径（例如 C:\\mingw64\\bin\\g++.exe 或 C:\\msys64\\ucrt64\\bin\\g++.exe）。\nIntelliSense 模式 会自动选择 windows-gcc-x64。\n保存后，VS Code 会自动在项目下创建 .vscode/c_cpp_properties.json 文件。\n\n\n配置编译任务 (tasks.json):\n\n按下 Ctrl + Shift + P，输入 Tasks: Configure Default Build Task。\n在弹出的选项中选择 C&#x2F;C++: g++.exe build active file。\nVS Code 会自动创建 .vscode/tasks.json 文件。这个文件定义了如何调用 g++ 编译器来编译你的代码。\n\n\n配置调试器 (launch.json):\n\n切换到“运行和调试”侧边栏（Ctrl + Shift + D）。\n点击“创建 launch.json 文件”，在弹出的环境中选择 C++ (GDB&#x2F;LLDB)。\n接着选择 g++.exe - 生成和调试活动文件。\nVS Code 会自动创建 .vscode/launch.json 文件。它告诉调试器如何启动你的程序，并自动关联了上一步创建的编译任务。\n\n\n\n第五步：编译、运行和调试所有配置都已完成！现在来享受成果吧。\n\n编译: 打开 main.cpp 文件，按下 Ctrl + Shift + B 来执行默认的编译任务。如果一切顺利，终端会显示编译成功，并且在文件浏览器中会看到一个 main.exe 文件。\n\n运行和调试:\n\n在 main.cpp 文件的 std::cout &lt;&lt; word &lt;&lt; &quot; &quot;; 这一行左侧点击，设置一个红点断点。\n按下 F5 键启动调试。\n代码会在你设置的断点处暂停。此时你可以查看左侧的变量值、调用堆栈，并使用调试控制栏（F10 单步跳过，F11 单步进入）来逐行执行代码。\n\n\n\n总结恭喜你！你已经成功搭建了一个功能完善的 C&#x2F;C++ 开发环境。通过这套配置，你不仅可以编写和编译代码，还能利用 VS Code 强大的调试功能来分析和解决问题，极大地提升了开发效率。现在，开始你的 C++ 编程之旅吧！\n","categories":["技术教程"],"tags":["VS Code","C++","MinGW","教程","环境配置"]},{"title":"青云志","url":"/2025/08/30/%E9%9D%92%E4%BA%91%E5%BF%97/","content":"\n  \n    \n      Note\n\n    \n    \n      《青云志》无人扶我青云志， 我自踏雪至山巅。\n若是命中无此运， 孤身亦可登昆仑。\n红尘赠我三尺剑， 酒看瘦马一世街。\n世人朝路乃绝涧， 独见众生止步前。\n海到尽头天作岸， 山登绝顶我为峰。\n如若东山能再起， 大鹏展翅九万里。\n一入红尘梦易眞， 一朝悟透心境名。\n一朝悟道见真我， 昔日枷锁皆云烟。\n天门将至百运开， 拂尘轻笑问仙来。\n\n\n——近现代·佚名《青云志》\n    \n  \n\n\n  \n    &emsp;&emsp;佚名: 亦称无名氏，是指身份不明或者尚未了解姓名的人。源于古代或民间、不知由谁创作的文学、音乐作品会以佚名为作者名称。\n\n  \n\n\n\n","categories":["随记"],"tags":["随记"]}]